-- Enable UUID extension
create extension if not exists "uuid-ossp";

-- Profiles table (extends Supabase Auth)
create table public.profiles (
  id uuid references auth.users not null primary key,
  email text,
  full_name text,
  avatar_url text,
  role text default 'user',
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Boards table
create table public.boards (
  id bigint generated by default as identity primary key,
  user_id uuid references auth.users not null,
  title text not null,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  column_width integer default 365,
  is_active boolean default false -- Helper to track active board per user logic if needed, though we handle this in frontend mostly
);

-- Columns table
create table public.columns (
  id bigint generated by default as identity primary key,
  board_id bigint references public.boards on delete cascade not null,
  title text not null,
  color text default 'indigo',
  position integer not null, -- For ordering
  card_config jsonb default '{}'::jsonb, -- Store JSON config like enableMove, etc.
  default_reminder_enabled boolean default false,
  default_reminder_value integer,
  default_reminder_unit text,
  allow_card_overrides boolean default false,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Tasks table
create table public.tasks (
  id bigint generated by default as identity primary key,
  column_id bigint references public.columns on delete cascade not null,
  title text not null,
  description text,
  position integer not null, -- For ordering within column
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  reminder_enabled boolean default false,
  reminder_value integer,
  reminder_unit text,
  next_notification_at timestamp with time zone,
  sort_option_id text, -- For the custom sort status
  checklist jsonb default '[]'::jsonb -- For subtasks
);

-- Comments table
create table public.comments (
  id bigint generated by default as identity primary key,
  task_id bigint references public.tasks on delete cascade not null,
  user_id uuid references auth.users not null, -- Who wrote the comment
  text text not null,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- RLS Policies (Row Level Security) - Basic Setup allowing users to see their own data
-- For simplicity in this iteration, we will allow authenticated users to do everything on their own rows.

alter table public.profiles enable row level security;
create policy "Users can view own profile" on public.profiles for select using (auth.uid() = id);
create policy "Users can update own profile" on public.profiles for update using (auth.uid() = id);

alter table public.boards enable row level security;
create policy "Users can view own boards" on public.boards for select using (auth.uid() = user_id);
create policy "Users can insert own boards" on public.boards for insert with check (auth.uid() = user_id);
create policy "Users can update own boards" on public.boards for update using (auth.uid() = user_id);
create policy "Users can delete own boards" on public.boards for delete using (auth.uid() = user_id);

alter table public.columns enable row level security;
create policy "Users can view columns of own boards" on public.columns for select using (
  exists (select 1 from public.boards where boards.id = columns.board_id and boards.user_id = auth.uid())
);
create policy "Users can insert columns to own boards" on public.columns for insert with check (
  exists (select 1 from public.boards where boards.id = board_id and boards.user_id = auth.uid())
);
create policy "Users can update columns of own boards" on public.columns for update using (
  exists (select 1 from public.boards where boards.id = columns.board_id and boards.user_id = auth.uid())
);
create policy "Users can delete columns of own boards" on public.columns for delete using (
  exists (select 1 from public.boards where boards.id = columns.board_id and boards.user_id = auth.uid())
);

alter table public.tasks enable row level security;
create policy "Users can view tasks of own boards" on public.tasks for select using (
  exists (select 1 from public.columns join public.boards on columns.board_id = boards.id where columns.id = tasks.column_id and boards.user_id = auth.uid())
);
create policy "Users can insert tasks to own boards" on public.tasks for insert with check (
  exists (select 1 from public.columns join public.boards on columns.board_id = boards.id where columns.id = column_id and boards.user_id = auth.uid())
);
create policy "Users can update tasks of own boards" on public.tasks for update using (
  exists (select 1 from public.columns join public.boards on columns.board_id = boards.id where columns.id = tasks.column_id and boards.user_id = auth.uid())
);
create policy "Users can delete tasks of own boards" on public.tasks for delete using (
  exists (select 1 from public.columns join public.boards on columns.board_id = boards.id where columns.id = tasks.column_id and boards.user_id = auth.uid())
);

alter table public.comments enable row level security;
create policy "Users can view comments of own boards" on public.comments for select using (
  exists (select 1 from public.tasks join public.columns on tasks.column_id = columns.id join public.boards on columns.board_id = boards.id where tasks.id = comments.task_id and boards.user_id = auth.uid())
);
create policy "Users can insert comments to own boards" on public.comments for insert with check (
  auth.uid() = user_id -- Simplification: Any auth user can comment if they have access to the task (which is controlled by the logic above, but RLS on insert primarily checks the USER_ID match usually)
);
-- Note: A more strict policy would check the task hierarchy for insert too.

-- Trigger to create profile on signup
create or replace function public.handle_new_user()
returns trigger as $$
begin
  insert into public.profiles (id, email, full_name, avatar_url)
  values (new.id, new.email, new.raw_user_meta_data->>'full_name', new.raw_user_meta_data->>'avatar_url');
  return new;
end;
$$ language plpgsql security definer;

create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();
